#include "common.h"

extern "C" {
#include "model.h"
}

// Create our various arrays.

double voi = 0.0;
double *states = createStatesArray();
double *rates = createStatesArray();
double *constants = createConstantsArray();
double *computedConstants = createComputedConstantsArray();
double *algebraic = createAlgebraicArray();
double *resetConditions = createResetConditionsArray();
double oldVoi = NAN;
double *oldStates = createStatesArray();
double *oldRates = createStatesArray();
double *oldConstants = createConstantsArray();
double *oldComputedConstants = createComputedConstantsArray();
double *oldAlgebraic = createAlgebraicArray();

enum {
    SizeOfDouble = sizeof(double)
};

void backupData()
{
    oldVoi = voi;
    memcpy(oldStates, states, STATE_COUNT * SizeOfDouble);
    memcpy(oldRates, rates, STATE_COUNT * SizeOfDouble);
    memcpy(oldConstants, constants, CONSTANT_COUNT * SizeOfDouble);
    memcpy(oldComputedConstants, computedConstants, COMPUTED_CONSTANT_COUNT * SizeOfDouble);
    memcpy(oldAlgebraic, algebraic, ALGEBRAIC_COUNT * SizeOfDouble);
}

void retrieveData()
{
    voi = oldVoi;
    memcpy(states, oldStates, STATE_COUNT * SizeOfDouble);
    memcpy(rates, oldRates, STATE_COUNT * SizeOfDouble);
    memcpy(constants, oldConstants, CONSTANT_COUNT * SizeOfDouble);
    memcpy(computedConstants, oldComputedConstants, COMPUTED_CONSTANT_COUNT * SizeOfDouble);
    memcpy(algebraic, oldAlgebraic, ALGEBRAIC_COUNT * SizeOfDouble);
}

void computeModel(double step, double voiEnd)
{
    // Compute f(t_n, Y_n).

    computeRates(voi, states, rates, constants, computedConstants, algebraic);

    // Compute Y_n+1.

    for (size_t i = 0; i < STATE_COUNT; ++i) {
        states[i] += step * rates[i];
    }

    // Update the VOI.

    voi = voiEnd;

    // Compute our variables.

    computeVariables(voi, states, rates, constants, computedConstants, algebraic);
}

int main()
{
    // Initialise our states, rates, constants, computed constants, and algebraic variables and output their initial
    // value/guess.

    initialiseVariables(states, rates, constants, computedConstants, algebraic);
    computeComputedConstants(constants, computedConstants);
    computeRates(voi, states, rates, constants, computedConstants, algebraic);
    computeVariables(voi, states, rates, constants, computedConstants, algebraic);

    std::ofstream file("@EXECUTABLE_SOLVER@.csv");

    printHeaders(file);

    // Run our model.

    double voiMax = @ENDING_POINT@;
    size_t voiIntervalCounter = 0;
    double voiInterval = @POINT_INTERVAL@;
    double step = @STEP@;

    printValues(file, voi, states, constants, computedConstants, algebraic);

    do {
        size_t voiCounter = 0;
        double fromVoi = voi;
        double voiEnd = (++voiIntervalCounter * voiInterval > voiMax) ? voiMax : voi + voiInterval;
        double realStep = step;

        do {
            // Backup our data.

            backupData();

            // Determine what realStep and toVoi should be.

            double toVoi = fromVoi + ++voiCounter * step;

            if (toVoi > voiEnd) {
                realStep = voiEnd - voi;
                toVoi = voiEnd;
            }

            // Compute the model.

            computeModel(realStep, toVoi);

            // Check for resets.

            do {
                int ret = applyResets(voi, states, rates, constants, computedConstants, algebraic, resetConditions);

                if (ret == 0) {
                    break;
                } else if (ret == 1) {
                    computeVariables(voi, states, rates, constants, computedConstants, algebraic);
                } else { // ret == 2.
                    // The reset condition has changed sign, so we need to determine the point at which it did, this
                    // using a binary search algorithm.

                    double lVoi = oldVoi;
                    double rVoi = voi;

                    while (true) {
                        retrieveData();

                        double midVoi = 0.5 * (lVoi + rVoi);

                        computeModel(midVoi - voi, midVoi);

                        int midRet = applyResets(voi, states, rates, constants, computedConstants, algebraic, resetConditions);

                        if (midRet == 1) {
                            // We have found the point at which the reset condition changed sign, so we now need to
                            // finish computing the model until voiEnd.

                            computeModel(voiEnd - midVoi, voiEnd);

                            break;
                        } else if (midRet == 0) {
                            lVoi = midVoi;
                        } else { // midRet == 2.
                            rVoi = midVoi;
                        }
                    }
                }
            } while (true);
        } while (voi < voiEnd);

        // Output the value of our states, constants, computed constants, and algebraic variables.

        printValues(file, voi, states, constants, computedConstants, algebraic);
    } while (voi < voiMax);

    file.close();

    // Clean up after ourselves.

    deleteArray(states);
    deleteArray(rates);
    deleteArray(constants);
    deleteArray(computedConstants);
    deleteArray(algebraic);
    deleteArray(resetConditions);
    deleteArray(oldStates);
    deleteArray(oldRates);
    deleteArray(oldConstants);
    deleteArray(oldComputedConstants);
    deleteArray(oldAlgebraic);

    return 0;
}
